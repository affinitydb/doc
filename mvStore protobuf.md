#Protocol-Buffer Interface for mvStore
Protocol-Buffers (aka _protobuf_) are Google's open-source interchange format. This format was designed to provide generic encoding
and decoding of structured data in an efficient manner (that is both language and platform neutral). It enjoyed a popularity
that resulted in widespread support across many platforms.

mvStore uses protobuf as a vehicle to export data outside of a store, and to import data (or updates) into a store.
As such, protobuf can be viewed as another interface to mvStore, albeit a rather low-level interface.
In most cases, the developer writing client code for mvStore is not expected to interact directly with protobuf.

There are several obvious situations where the protobuf interface can be useful: dump & load, replication, inter-store messaging etc.

Another important use case is when protobuf is combined with [mvSQL](./terminology.md#mvsql) to implement
language-specific access layers for mvStore (aka [client libraries](./terminology.md#client-side-libraries)). In this context, protobuf
acts as a middle-man between the language's object model _(effectively allowing to export/serialize objects outside of the language
and import/deserialize objects back into the language)_ and mvStore's own data model. This reduces
considerably the need for an ORM when using mvStore _(because mvStore's internal data model maps directly
with the core native object model of most languages)_.

Here are two typical examples.

A client _writes_ to mvStore:

  the client has a javascript object to be stored in mvStore
  -> the client serializes it to protobuf, as a new object to be inserted (OP_INSERT)
  -> the client sends the serialized stream to mvStore
  -> mvStore deserializes the protobuf stream into its own internal data model
  -> mvStore detects OP_INSERT and stores the new object
  -> mvStore produces a response (including new PID, new eids etc.)
  -> mvStore serializes the response to protobuf
  -> the client deserializes the response

A client _reads_ from mvStore:

  the client wants to query PIN @50001 and interact with it as an object
  -> the client emits the query 'SELECT * FROM @50001;' via a protobuf-enabled interface
  -> mvStore executes the query and serializes the response to protobuf
  -> the client deserializes the response into a javascript object

The internal structure of the protobuf messages that can be understood by mvStore is defined in
[mvstore.proto](../kernel/src/mvstore.proto). It allows to express PIN inserts, updates and deletes,
as well as generic queries, transactions, long-running transactions etc. It also provides extensive support for
fine-grained updates, such as modifying the order of elements in a collection (e.g. `OP_MOVE_BEFORE`),
performing server-side read-modify-write on specific properties (e.g. `OP_PLUS`), etc.

_Note: The process of serializing to protobuf and deserializing back into
a client's object model may require a translation. Even though protobuf libraries
typically produce a language-compliant structure, that structure is defined by mvstore.proto, for
serialization purposes, and may not be sufficiently usable as a client object model. For example, mvstore.proto
stores all property names as indexes, alongside a local translation table (for space efficiency).
Typically, most languages will prefer to expose objects in a more natural form, where properties
are standard named entities. This kind of translation is usually implemented in the
client access library (e.g. [mvstore-client.js](../nodejs/mvstore-client/lib/mvstore-client.js) or
[mvstore.py](../python/mvstore.py))._

###A Closer Look at mvstore.proto
All the components of a protobuf stream sent to or received from mvStore are defined in
[mvstore.proto](../kernel/src/mvstore.proto). The main elements of the structure are:

 * Value
 * PID
 * MVStream.PIN
 * MVStream.MVSQL
 * MVStream

`Value` corresponds to the [basic notion of value](./terminology.md#value) used throughout the documentation,
and constitutes the main building block of a `MVStream.PIN` (the [PIN](./terminology.md#pin)). `PID` defines
the serialization format of [PIN IDs](./terminology.md#pin-id-pid), which are generated by mvStore initially, and
are then used to refer to existing PINs (e.g. to read, modify or delete them). `MVStream.MVSQL` allows to insert
mvSQL statements in a protobuf stream (thus implying a serialized query result in the protobuf response,
often in the form of an array of `MVStream.PIN` objects).

`MVStream` defines the possible contents of any of the contiguous segments of data in the
actual physical stream. In other words, it should be possible to dissect any physical stream 
compliant with [mvstore.proto](../kernel/src/mvstore.proto) and find a series of `MVStream` instances.

For example, the physical input and output streams involved in fetching a PIN, testing some conditions
and then modifying the PIN in a single transaction could look like this (where each column is
a physical stream, and each row represents one `MVStream` segment of it):

Physical stream sent to mvStore                                                   Physical stream returned by mvStore
-------------------------------                                                   -----------------------------------
{ txop:[TX_START] }
{ stmt:[{ sq:"SELECT * FROM @50001;", rtt:RT_PINS }], flush:[0] }
                                                                                  { result:[...], properties:[...], pins:[{ id:{ id:50001 }, values:[...], ... }] }
_Note: Here comes the client-side logic to decide what to do with the PIN._
{ pins:[{ op:OP_UPDATE, id:{ id:50001 }, ... }], properties:[...], flush:[0] }
                                                                                  { result:[...], properties:[...], pins:[{ id:{ id:50001 }, ... }] }
{ txop:[TX_COMMIT] }
                                                                                  { result:[...] }

<sub>
Note: This sequence is typically implemented as a single HTTP connection.
</sub>

[mvstore.proto](../kernel/src/mvstore.proto) contains more structures and fields than described here.
It also contains a large number of `enums`, some of which are sometimes used as constants _(n.b.:
some protobuf libraries don't support this strategy, in which case the values in mvstore.proto must
be repeated as literals in the client code)_. Please refer to the comments in [mvstore.proto](../kernel/src/mvstore.proto)
for more information.

###About Streaming and Pagination
mvStore offers two distinct and complementary strategies for dealing with data streaming.

The simplest strategy consists in letting the client specify pagination OFFSET and LIMIT along with its mvSQL statement.
This can be done via `MVStream.MVSQL.offset` and `MVStream.MVSQL.limit` (directly in the protobuf request).
[mvServer](./mvStore server.md) also allows to specify these parameters. mvStore interprets them
and returns a subset of the whole result set _(n.b. in the current implementation, the query
is re-evaluated for every requested page; consistency can be secured with a transaction, but the performance
is not optimal)_. The granularity is the PIN, which may be insufficient in some
cases, such as data models involving huge collections.

The second strategy involves a different method of reading the response stream, one atomic element at a time
(instead of one `MVStream`-segment at a time). This strategy provides full control over the stream (and
the memory footprint involved in reading it). On the other hand, it also comes at a cost:
on one hand, it usually implies a completely different programming model (if you can't afford to put a
whole PIN in memory, then you probably can't interact with that object as a native object either);
on the other hand, not all protobuf libraries expose this kind of access.

In their present implementation, the [node.js](../nodejs/mvstore-client/lib/mvstore-client.js) and
[python](../python/mvstore.py) client libraries only support the first strategy, but may expose a
specialized interface using the second strategy in a near future.

###More Information
For more information on mvStore's usage of protobuf, please refer to the comments in [mvstore.proto](../kernel/src/mvstore.proto).
Another important source of information is the implementation of the [node.js](../nodejs/mvstore-client/lib/mvstore-client.js) and
[python](../python/mvstore.py) access layers, which can be used as examples to implement new access layers.

For more information about Google's protobuf, please refer to the project's [homepage](http://code.google.com/p/protobuf),
its [deleloper guide](http://code.google.com/apis/protocolbuffers/docs/overview.html) and its
[format helper](http://code.google.com/apis/protocolbuffers/docs/proto.html).
