<div id="getting-started-with-mvsql"
><h1
  >Getting Started with mvSQL</h1
  ><p
  >mvSQL is the name of a dialect of SQL defined for mvStore. Although the <a href="./terminology.html#essential-concepts-data-model"
    >mvStore data model</a
    > is different from relational databases, mvSQL is designed to be as close to SQL as possible. This document shows <strong
    >how to</strong
    > insert, update, query and index data (<a href="./terminology.html#pin"
    >PINs</a
    >).</p
  ><p
  >For a more systematic survey of mvSQL and its commands, please visit the <a href="./mvSQL%20reference.html"
    >reference</a
    >.</p
  ><p
  >To setup a runtime environment, please visit this <a href="./mvStore%20getting%20started.html"
    >link</a
    >.</p
  ><div id="how-to-insert-data"
  ><h2
    >How to insert data</h2
    ><p
    >There is no concept of table in mvStore: all data are inserted in global scope. Two styles can be used to perform <a href="./terminology.html#pin"
      >PIN</a
      > inserts:</p
    ><ol style="list-style-type: decimal;"
    ><li
      ><p
	>SQL-like syntax:</p
	><pre
	><code
	  >INSERT (property1, property2) VALUES ('value1','value2');  
</code
	  ></pre
	></li
      ><li
      ><p
	>mvStore-specific syntax:</p
	><pre
	><code
	  >INSERT property1 ='value1', property2 ='value2';
</code
	  ></pre
	></li
      ></ol
    ><p
    >Different <a href="./mvSQL%20reference.html#data-types"
      >data types</a
      > may have different input formats, e.g.</p
    ><p
    >mvcommand&gt; INSERT prop_string ='string', prop_binary_string =X'DEF5', prop_url=U'http://test/', prop_int=128, prop_float=3.40282e+038f, prop_double=3.40282e+038, prop_bool=true, prop_datatime=TIMESTAMP '2010-12-31 23:59:59', prop_internal=INTERVAL '-12:00:00', prop_collection={1,2,4};<br
       /> PIN@00000000000D000D(10):(&lt;prop_string|VT_STRING&gt;:string &lt;prop_binary_string|VT_BSTR&gt;:DEF5 &lt;prop_url|VT_URL&gt;:http://test/ &lt;prop_int|VT_INT&gt;:128&lt;prop_float|VT_FLOAT&gt;:3.40282e+038 &lt;prop_double|VT_DOUBLE&gt;:3.40282e+038&lt;prop_bool|VT_BOOL&gt;:TRUE &lt;prop_datatime|VT_DATETIME&gt;:2010-12-31 23:59:59&lt;prop_internal|VT_INTERVAL&gt;:-12:00:00 &lt;prop_collection|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_INT&gt;:2, &lt;2|VT_INT&gt;:4}) 1 PINs INSERTED.</p
    ><p
    >Other examples:</p
    ><p
    >INSERT name='Jurgen', bornin='South Africa', email='jleschner@vmware.com', livesin='Boston'; {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}</p
    ><p
    >INSERT (name, bornin, email, livesin) VALUES ('Sonny', 'USA', 'sthai@mit.edu', 'Boston'); {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: &quot;Boston&quot;}</p
    ></div
  ><div id="how-to-update-or-delete-data"
  ><h2
    >How to update or delete data</h2
    ><p
    >UPDATE ADD livesin='Cambridge' WHERE name = 'Sonny'; {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;Cambridge&quot;}}</p
    ><p
    >UPDATE SET livesin[1]='USA' WHERE name='Sonny'; {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}}</p
    ><p
    >UPDATE @A0001 ADD school='MIT'; {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}</p
    ><p
    >delete @A0001;</p
    ></div
  ><div id="how-to-classify-data"
  ><h2
    >How to classify data</h2
    ><p
    >All data are inserted in global scope, but applications can freely define specialized access paths for their data (before or after the data is inserted), by creating what we call <a href="./terminology.html#class"
      >classes</a
      >. Here's an example:</p
    ><pre
    ><code
      >    CREATE CLASS class1 AS select * where property1 is not null;
</code
      ></pre
    ></div
  ><div id="how-to-query"
  ><h2
    >How to query</h2
    ><p
    >Most of the querying syntax in mvStore is compatible with standard SQL: expressions, function calls, WHERE, ORDER BY, UNION, INTERSECT, EXCEPT etc. Here's an example:</p
    ><pre
    ><code
      >    SELECT * FROM class1 WHERE LENGTH(property2) + LENGTH(property2) &gt; 5 ORDER BY property2 DESC NULLS FIRST;
</code
      ></pre
    ><p
    ><em
      >Note:</em
      > mvStore does not yet support two important features:<br
       />1. PROJECTION (property or expression in the SELECT clause, instead of *)<br
       />2. GROUP BY</p
    ><p
    >Other examples:</p
    ><p
    >SELECT WHERE livesin = 'Boston' ORDER BY name ASC; {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;} {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}</p
    ><p
    >SELECT * MATCH AGAINST ('Boston'); {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;} {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}</p
    ><p
    >SELECT * MATCH AGAINST ('South'); {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}</p
    ></div
  ><div id="how-to-use-join"
  ><h2
    >How to use join</h2
    ><p
    >mvStore returns immutable PIN collections as query results. Presently, the join results are somewhat limited (they only contain PINs from the left-hand class). Here's an example:</p
    ><pre
    ><code
      >    SELECT * FROM class1 as c1 join class1 as c2 on (c1.prop1 = c2.prop2);
</code
      ></pre
    ><p
    >mvStore supports every kind of JOIN (LEFT/RIGHT/FULL/CROSS JOIN), except the Natural JOIN.</p
    ></div
  ><div id="how-to-use-references"
  ><h2
    >How to use <a href="./terminology.html#pin-reference"
      >references</a
      ></h2
    ><p
    >Relational databases use foreign keys to establish relationships between tables. mvStore uses <a href="./terminology.html#pin-reference"
      >references</a
      >, similarly to object-oriented databases:</p
    ><p
    >mvcommand&gt; INSERT (prop1) VALUES ({'test for pin refer', 'test for property refer', 'test for property element refer'}); PIN@0000000000050001(1):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_STRING&gt;:test for pin refer,&lt;1|VT_STRING&gt;:test for property refer, &lt;2|VT_STRING&gt;:test for property element refer}) 1 PINs INSERTED.</p
    ><p
    >mvcommand&gt; INSERT (propRef, prop2) VALUES (@50001, 'test for ref pin'); PIN@0000000000050002(2):(&lt;propRef|VT_REFID&gt;:PIN@0000000000050001 &lt;prop2|VT_STRING&gt;:test for ref pin) 1 PINs INSERTED.</p
    ><p
    >mvcommand&gt; INSERT (propRef, prop2) VALUES (@50001.prop1, 'test for ref property'); PIN@0000000000050003(2):(&lt;propRef|VT_REFIDPROP&gt;:PIN@0000000000050001.prop1&lt;prop2|VT_STRING&gt;:test for ref property) 1 PINs INSERTED.</p
    ><p
    >mvcommand&gt; INSERT (propRef, prop2) VALUES (@50001.prop1[2], 'test for ref property element'); PIN@0000000000050004(2):(&lt;propRef|VT_REFIDELT&gt;:PIN@0000000000050001.prop1[2]&lt;prop2|VT_STRING&gt;:test for ref property element) 1 PINs INSERTED.</p
    ><p
    >To leverage this information while querying, mvStore offers the following syntax (path expression):</p
    ><p
    >SELECT * WHERE COUNT(propRef.prop1) &gt; 1; SELECT * FROM myclass WHERE propRef.prop2 IN (1, 2, 3);</p
    ><p style="color:red">REVIEW (maxw): this is just a quick intro, and actually the kernel implementation is commented out presently... when it works, I'll augment this.</p>
</div
  ><div id="how-to-use-collections"
  ><h2
    >How to use <a href="./terminology.html#collection"
      >collections</a
      ></h2
    ><div id="add-elements-to-a-collection"
    ><h3
      >1. Add elements to a <a href="./terminology.html#collection"
	>collection</a
	></h3
      ><div id="insert-a-pin-with-a-collection-property:"
      ><h4
	>1.1 Insert a PIN with a collection property:</h4
	><p
	>mvcommand&gt;INSERT (prop1, prop2) VALUES ({1, 'inserted', '3'}, 2); PIN@0000000000050001(2):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3} &lt;prop2|VT_INT&gt;:2) 1 PINs INSERTED.</p
	></div
      ><div id="update-a-property-in-a-collection"
      ><h4
	>1.2 Update a property in a collection</h4
	><p
	>Using &quot;UPDATE ... SET ...&quot;, we can replace a property with a whole collection directly:</p
	><p
	>UPDATE @50001 SET prop3={3, 'update set'};<br
	   /> PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3} &lt;prop2|VT_INT&gt;:2 &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})<br
	   /> 1 PINs UPDATED.</p
	><p
	>Using &quot;UPDATE ... ADD ...&quot;, we can convert a property from a scalar value to a collection:</p
	><p
	>UPDATE @50001 ADD prop2='update add';<br
	   /> PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3} &lt;prop2|VT_ARRAY(2)&gt;:{&lt;prop2|VT_INT&gt;:2, &lt;prop2|VT_STRING&gt;:updateadd} &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})<br
	   /> 1 PINs UPDATED.</p
	></div
      ></div
    ><div id="delete-an-element-from-a-collection"
    ><h3
      >2. Delete an element from a collection</h3
      ><p
      >UPDATE @50001 DELETE prop1[2];<br
	 /> PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted} &lt;prop2|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:2, &lt;1|VT_STRING&gt;:update add} &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})<br
	 /> 1 PINs UPDATED.</p
      ></div
    ><div id="query-on-collections"
    ><h3
      >3. Query on collections</h3
      ><p
      >Here are a few examples of queries that can be run against the PIN created in section 1.1:</p
      ><blockquote
      ><ol style="list-style-type: decimal;"
	><li
	  >SELECT * WHERE 1 IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE {1,2} IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE CARDINALITY(prop1)=2;<br
	     /></li
	  ><li
	  >SELECT * WHERE 1 = prop1; -- equivalent to example 1.</li
	  ><li
	  >SELECT * WHERE {1,2} = prop1; -- equivalent to example 2.</li
	  ></ol
	></blockquote
      ></div
    ></div
  ><div id="how-to-index-properties"
  ><h2
    >How to index properties</h2
    ><p
    >mvStore does not support the &quot;CREATE INDEX&quot; statement. However, it proposes a somewhat similar statement: &quot;CREATE CLASS family&quot;. Here's an example:</p
    ><pre
    ><code
      >    CREATE CLASS clsfml1 AS select * where prop1 = :0(int, desc, nulls first) and prop2=:1(int);   
</code
      ></pre
    ><p
    >This class <a href="./terminology.html#family"
      >family</a
      > will create an <a href="./terminology.html#index"
      >index</a
      > on prop1 and prop2. The prop1 will be sorted in descending order, and will order nulls first. When parameters are passed, the class family behaves like a CLASS. For example:</p
    ><p
    >mvcommand&gt; SELECT * FROM clsfml5(*, 2);<br
       /> PIN@0000000000050012(2):(&lt;prop2|VT_INT&gt;:2 &lt;prop3|VT_STRING&gt;:test NULL)<br
       /> PIN@0000000000050013(3):(&lt;prop1|VT_DOUBLE&gt;:13.3 &lt;prop2|VT_INT&gt;:2 &lt;prop3|VT_STRING&gt;:extra)<br
       /> PIN@0000000000050018(2):(&lt;prop1|VT_DOUBLE&gt;:12.1 &lt;prop2|VT_INT&gt;:2)<br
       /> PIN@0000000000050019(3):(&lt;prop1|VT_INT&gt;:12 &lt;prop2|VT_INT&gt;:2 &lt;prop3|VT_DOUBLE&gt;:34)<br
       /> 4 PINs SELECTED.</p
    ></div
  ></div
>
